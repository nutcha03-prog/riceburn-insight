"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_components_map-component_tsx",{

/***/ "(app-pages-browser)/./components/map-component.tsx":
/*!**************************************!*\
  !*** ./components/map-component.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MapComponent)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.6_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.6_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/.pnpm/leaflet@1.9.4/node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var leaflet_heat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet.heat */ \"(app-pages-browser)/./node_modules/.pnpm/leaflet.heat@0.2.0/node_modules/leaflet.heat/dist/leaflet-heat.js\");\n/* harmony import */ var leaflet_heat__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(leaflet_heat__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @turf/turf */ \"(app-pages-browser)/./node_modules/.pnpm/@turf+helpers@7.2.0/node_modules/@turf/helpers/dist/esm/index.js\");\n/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @turf/turf */ \"(app-pages-browser)/./node_modules/.pnpm/@turf+boolean-point-in-polygon@7.2.0/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js\");\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"(app-pages-browser)/./node_modules/.pnpm/leaflet@1.9.4/node_modules/leaflet/dist/leaflet.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction MapComponent(param) {\n    let { selectedMonth, showHotspots, onStatsUpdate } = param;\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MapComponent.useEffect\": ()=>{\n            // ⛔ Prevent SSR\n            if (false) {}\n            // ⭐ FIX #1: Prevent multiple Leaflet initializations\n            const mapContainer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().DomUtil.get('map');\n            if (mapContainer && mapContainer._leaflet_id) {\n                ;\n                mapContainer._leaflet_id = null;\n            }\n            // ⭐ Create map safely\n            const map = leaflet__WEBPACK_IMPORTED_MODULE_2___default().map('map', {\n                center: [\n                    16.7,\n                    100.5\n                ],\n                zoom: 6\n            });\n            // Basemap\n            leaflet__WEBPACK_IMPORTED_MODULE_2___default().tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {\n                attribution: 'Esri, Maxar'\n            }).addTo(map);\n            let hotspotLayer = null;\n            let heatLayer = null;\n            let topProvinceLayer = null;\n            let boundaryLayer = null;\n            // Load boundary\n            const loadBoundary = {\n                \"MapComponent.useEffect.loadBoundary\": async ()=>{\n                    const boundary = await fetch('/geo/provinces.geojson').then({\n                        \"MapComponent.useEffect.loadBoundary\": (r)=>r.json()\n                    }[\"MapComponent.useEffect.loadBoundary\"]);\n                    // ⭐ FIX #2: Ensure valid geometry\n                    boundaryLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().geoJSON(boundary, {\n                        style: {\n                            color: '#555',\n                            weight: 1,\n                            fillOpacity: 0\n                        }\n                    });\n                    boundaryLayer.addTo(map);\n                    return boundary;\n                }\n            }[\"MapComponent.useEffect.loadBoundary\"];\n            const loadHotspot = {\n                \"MapComponent.useEffect.loadHotspot\": async (month)=>{\n                    const file = \"/geo/Hotspot_inrice_\".concat(month, \".geojson\");\n                    const geo = await fetch(file).then({\n                        \"MapComponent.useEffect.loadHotspot\": (r)=>r.json()\n                    }[\"MapComponent.useEffect.loadHotspot\"]);\n                    if (hotspotLayer) map.removeLayer(hotspotLayer);\n                    if (heatLayer) map.removeLayer(heatLayer);\n                    if (topProvinceLayer) map.removeLayer(topProvinceLayer);\n                    hotspotLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().geoJSON(geo, {\n                        pointToLayer: {\n                            \"MapComponent.useEffect.loadHotspot\": (_, latlng)=>leaflet__WEBPACK_IMPORTED_MODULE_2___default().circleMarker(latlng, {\n                                    radius: 5,\n                                    fillColor: '#ff3b3b',\n                                    color: '#fff',\n                                    weight: 1,\n                                    fillOpacity: 0.9\n                                })\n                        }[\"MapComponent.useEffect.loadHotspot\"],\n                        onEachFeature: {\n                            \"MapComponent.useEffect.loadHotspot\": (f, l)=>{\n                                const p = f.properties;\n                                l.bindPopup(\"\\n            <b>\\uD83D\\uDD25 Hotspot</b><br/>\\n            วันที่: \".concat(p.DATE || '-', \"<br/>\\n            จังหวัด: \").concat(p.PROVINCE || '-', \"\\n          \"));\n                            }\n                        }[\"MapComponent.useEffect.loadHotspot\"]\n                    });\n                    if (showHotspots) hotspotLayer.addTo(map);\n                    // Heatmap\n                    const pts = geo.features.map({\n                        \"MapComponent.useEffect.loadHotspot.pts\": (f)=>[\n                                f.geometry.coordinates[1],\n                                f.geometry.coordinates[0]\n                            ]\n                    }[\"MapComponent.useEffect.loadHotspot.pts\"]);\n                    heatLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().heatLayer(pts, {\n                        radius: 25,\n                        blur: 20,\n                        maxZoom: 9\n                    });\n                    if (showHotspots) heatLayer.addTo(map);\n                    // Count per province\n                    const boundary = await fetch('/geo/provinces.geojson').then({\n                        \"MapComponent.useEffect.loadHotspot\": (r)=>r.json()\n                    }[\"MapComponent.useEffect.loadHotspot\"]);\n                    const counts = {};\n                    geo.features.forEach({\n                        \"MapComponent.useEffect.loadHotspot\": (pt)=>{\n                            const [lon, lat] = pt.geometry.coordinates;\n                            const point = _turf_turf__WEBPACK_IMPORTED_MODULE_5__.point([\n                                lon,\n                                lat\n                            ]);\n                            boundary.features.forEach({\n                                \"MapComponent.useEffect.loadHotspot\": (f)=>{\n                                    let poly;\n                                    if (f.geometry.type === 'Polygon') poly = _turf_turf__WEBPACK_IMPORTED_MODULE_5__.polygon(f.geometry.coordinates);\n                                    else if (f.geometry.type === 'MultiPolygon') poly = _turf_turf__WEBPACK_IMPORTED_MODULE_5__.multiPolygon(f.geometry.coordinates);\n                                    if (_turf_turf__WEBPACK_IMPORTED_MODULE_6__.booleanPointInPolygon(point, poly)) {\n                                        const prov = f.properties.pro_th;\n                                        counts[prov] = (counts[prov] || 0) + 1;\n                                    }\n                                }\n                            }[\"MapComponent.useEffect.loadHotspot\"]);\n                        }\n                    }[\"MapComponent.useEffect.loadHotspot\"]);\n                    const sorted = Object.entries(counts).sort({\n                        \"MapComponent.useEffect.loadHotspot.sorted\": (a, b)=>b[1] - a[1]\n                    }[\"MapComponent.useEffect.loadHotspot.sorted\"]);\n                    let topProvince = \"-\";\n                    if (sorted.length > 0) {\n                        topProvince = \"\".concat(sorted[0][0], \" (\").concat(sorted[0][1], \" จุด)\");\n                        const topFeature = boundary.features.find({\n                            \"MapComponent.useEffect.loadHotspot.topFeature\": (f)=>f.properties.pro_th === sorted[0][0]\n                        }[\"MapComponent.useEffect.loadHotspot.topFeature\"]);\n                        if (topFeature) {\n                            topProvinceLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().geoJSON(topFeature, {\n                                style: {\n                                    color: 'black',\n                                    weight: 3,\n                                    fillOpacity: 0.25\n                                }\n                            }).addTo(map);\n                        }\n                    }\n                    onStatsUpdate({\n                        totalHotspots: geo.features.length,\n                        topProvince\n                    });\n                }\n            }[\"MapComponent.useEffect.loadHotspot\"];\n            loadBoundary().then({\n                \"MapComponent.useEffect\": ()=>loadHotspot(selectedMonth)\n            }[\"MapComponent.useEffect\"]);\n            return ({\n                \"MapComponent.useEffect\": ()=>{\n                    if (map) map.remove();\n                }\n            })[\"MapComponent.useEffect\"];\n        }\n    }[\"MapComponent.useEffect\"], [\n        selectedMonth,\n        showHotspots\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"map\",\n        className: \"h-[700px] w-full\"\n    }, void 0, false, {\n        fileName: \"D:\\\\AI\\\\my-riceburn\\\\components\\\\map-component.tsx\",\n        lineNumber: 153,\n        columnNumber: 10\n    }, this);\n}\n_s(MapComponent, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = MapComponent;\nvar _c;\n$RefreshReg$(_c, \"MapComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvbWFwLWNvbXBvbmVudC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUVpQztBQUNWO0FBQ0Y7QUFDYTtBQUNEO0FBUWxCLFNBQVNHLGFBQWEsS0FBd0Q7UUFBeEQsRUFBRUMsYUFBYSxFQUFFQyxZQUFZLEVBQUVDLGFBQWEsRUFBWSxHQUF4RDs7SUFFbkNOLGdEQUFTQTtrQ0FBQztZQUVSLGdCQUFnQjtZQUNoQixJQUFJLEtBQTZCLEVBQUU7WUFFbkMscURBQXFEO1lBQ3JELE1BQU1PLGVBQWVOLHNEQUFTLENBQUNRLEdBQUcsQ0FBQztZQUNuQyxJQUFJRixnQkFBZ0IsYUFBc0JHLFdBQVcsRUFBRTs7Z0JBQ2xESCxhQUFxQkcsV0FBVyxHQUFHO1lBQ3hDO1lBRUEsc0JBQXNCO1lBQ3RCLE1BQU1DLE1BQU1WLGtEQUFLLENBQUMsT0FBTztnQkFBRVcsUUFBUTtvQkFBQztvQkFBTTtpQkFBTTtnQkFBRUMsTUFBTTtZQUFFO1lBRTFELFVBQVU7WUFDVlosd0RBQVcsQ0FBQyxpR0FBaUc7Z0JBQzNHYyxhQUFhO1lBQ2YsR0FBR0MsS0FBSyxDQUFDTDtZQUVULElBQUlNLGVBQW9CO1lBQ3hCLElBQUlDLFlBQWlCO1lBQ3JCLElBQUlDLG1CQUF3QjtZQUM1QixJQUFJQyxnQkFBcUI7WUFFekIsZ0JBQWdCO1lBQ2hCLE1BQU1DO3VEQUFlO29CQUNuQixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sMEJBQTBCQyxJQUFJOytEQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJOztvQkFFdkUsa0NBQWtDO29CQUNsQ04sZ0JBQWdCbkIsc0RBQVMsQ0FBQ3FCLFVBQVU7d0JBQ2xDTSxPQUFPOzRCQUFFQyxPQUFPOzRCQUFRQyxRQUFROzRCQUFHQyxhQUFhO3dCQUFFO29CQUNwRDtvQkFFQVgsY0FBY0osS0FBSyxDQUFDTDtvQkFFcEIsT0FBT1c7Z0JBQ1Q7O1lBRUEsTUFBTVU7c0RBQWMsT0FBT0M7b0JBQ3pC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OEIsUUFBUSxDQUFDMkIsSUFBSTs2RUFDdkMsQ0FBQ25DLElBQVdBLEVBQUVHLFVBQVUsQ0FBQ3NCLE1BQU0sS0FBS0MsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFOzt3QkFHbEQsSUFBSVEsWUFBWTs0QkFDZDNELG1CQUFtQmxCLHNEQUFTLENBQUM2RSxZQUFZO2dDQUN2Q2xELE9BQU87b0NBQUVDLE9BQU87b0NBQVNDLFFBQVE7b0NBQUdDLGFBQWE7Z0NBQUs7NEJBQ3hELEdBQUdmLEtBQUssQ0FBQ0w7d0JBQ1g7b0JBQ0Y7b0JBRUFMLGNBQWM7d0JBQ1owRSxlQUFlN0MsSUFBSWlCLFFBQVEsQ0FBQ3lCLE1BQU07d0JBQ2xDRDtvQkFDRjtnQkFDRjs7WUFFQXZELGVBQWVHLElBQUk7MENBQUMsSUFBTVEsWUFBWTVCOztZQUV0QzswQ0FBTztvQkFDTCxJQUFJTyxLQUFLQSxJQUFJc0UsTUFBTTtnQkFDckI7O1FBR0Y7aUNBQUc7UUFBQzdFO1FBQWVDO0tBQWE7SUFFaEMscUJBQU8sOERBQUM2RTtRQUFJQyxJQUFHO1FBQU1DLFdBQVU7Ozs7OztBQUNqQztHQTNJd0JqRjtLQUFBQSIsInNvdXJjZXMiOlsiRDpcXEFJXFxteS1yaWNlYnVyblxcY29tcG9uZW50c1xcbWFwLWNvbXBvbmVudC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IEwgZnJvbSAnbGVhZmxldCdcbmltcG9ydCAnbGVhZmxldC5oZWF0J1xuaW1wb3J0ICogYXMgdHVyZiBmcm9tICdAdHVyZi90dXJmJ1xuaW1wb3J0ICdsZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3MnXG5cbmludGVyZmFjZSBNYXBQcm9wcyB7XG4gIHNlbGVjdGVkTW9udGg6IHN0cmluZ1xuICBzaG93SG90c3BvdHM6IGJvb2xlYW5cbiAgb25TdGF0c1VwZGF0ZTogKHN0YXRzOiB7IHRvdGFsSG90c3BvdHM6IG51bWJlcjsgdG9wUHJvdmluY2U6IHN0cmluZyB9KSA9PiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1hcENvbXBvbmVudCh7IHNlbGVjdGVkTW9udGgsIHNob3dIb3RzcG90cywgb25TdGF0c1VwZGF0ZSB9OiBNYXBQcm9wcykge1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAvLyDim5QgUHJldmVudCBTU1JcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG5cbiAgICAvLyDirZAgRklYICMxOiBQcmV2ZW50IG11bHRpcGxlIExlYWZsZXQgaW5pdGlhbGl6YXRpb25zXG4gICAgY29uc3QgbWFwQ29udGFpbmVyID0gTC5Eb21VdGlsLmdldCgnbWFwJylcbiAgICBpZiAobWFwQ29udGFpbmVyICYmIChtYXBDb250YWluZXIgYXMgYW55KS5fbGVhZmxldF9pZCkge1xuICAgICAgOyAobWFwQ29udGFpbmVyIGFzIGFueSkuX2xlYWZsZXRfaWQgPSBudWxsXG4gICAgfVxuXG4gICAgLy8g4q2QIENyZWF0ZSBtYXAgc2FmZWx5XG4gICAgY29uc3QgbWFwID0gTC5tYXAoJ21hcCcsIHsgY2VudGVyOiBbMTYuNywgMTAwLjVdLCB6b29tOiA2IH0pXG5cbiAgICAvLyBCYXNlbWFwXG4gICAgTC50aWxlTGF5ZXIoJ2h0dHBzOi8vc2VydmVyLmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvV29ybGRfSW1hZ2VyeS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScsIHtcbiAgICAgIGF0dHJpYnV0aW9uOiAnRXNyaSwgTWF4YXInXG4gICAgfSkuYWRkVG8obWFwKVxuXG4gICAgbGV0IGhvdHNwb3RMYXllcjogYW55ID0gbnVsbFxuICAgIGxldCBoZWF0TGF5ZXI6IGFueSA9IG51bGxcbiAgICBsZXQgdG9wUHJvdmluY2VMYXllcjogYW55ID0gbnVsbFxuICAgIGxldCBib3VuZGFyeUxheWVyOiBhbnkgPSBudWxsXG5cbiAgICAvLyBMb2FkIGJvdW5kYXJ5XG4gICAgY29uc3QgbG9hZEJvdW5kYXJ5ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYm91bmRhcnkgPSBhd2FpdCBmZXRjaCgnL2dlby9wcm92aW5jZXMuZ2VvanNvbicpLnRoZW4ociA9PiByLmpzb24oKSlcblxuICAgICAgLy8g4q2QIEZJWCAjMjogRW5zdXJlIHZhbGlkIGdlb21ldHJ5XG4gICAgICBib3VuZGFyeUxheWVyID0gTC5nZW9KU09OKGJvdW5kYXJ5LCB7XG4gICAgICAgIHN0eWxlOiB7IGNvbG9yOiAnIzU1NScsIHdlaWdodDogMSwgZmlsbE9wYWNpdHk6IDAgfVxuICAgICAgfSlcblxuICAgICAgYm91bmRhcnlMYXllci5hZGRUbyhtYXApXG5cbiAgICAgIHJldHVybiBib3VuZGFyeVxuICAgIH1cblxuICAgIGNvbnN0IGxvYWRIb3RzcG90ID0gYXN5bmMgKG1vbnRoOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSBgL2dlby9Ib3RzcG90X2lucmljZV8ke21vbnRofS5nZW9qc29uYFxuICAgICAgY29uc3QgZ2VvID0gYXdhaXQgZmV0Y2goZmlsZSkudGhlbihyID0+IHIuanNvbigpKVxuXG4gICAgICBpZiAoaG90c3BvdExheWVyKSBtYXAucmVtb3ZlTGF5ZXIoaG90c3BvdExheWVyKVxuICAgICAgaWYgKGhlYXRMYXllcikgbWFwLnJlbW92ZUxheWVyKGhlYXRMYXllcilcbiAgICAgIGlmICh0b3BQcm92aW5jZUxheWVyKSBtYXAucmVtb3ZlTGF5ZXIodG9wUHJvdmluY2VMYXllcilcblxuICAgICAgaG90c3BvdExheWVyID0gTC5nZW9KU09OKGdlbywge1xuICAgICAgICBwb2ludFRvTGF5ZXI6IChfOiBhbnksIGxhdGxuZzogYW55KSA9PlxuICAgICAgICAgIEwuY2lyY2xlTWFya2VyKGxhdGxuZywge1xuICAgICAgICAgICAgcmFkaXVzOiA1LFxuICAgICAgICAgICAgZmlsbENvbG9yOiAnI2ZmM2IzYicsXG4gICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgd2VpZ2h0OiAxLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0pLFxuICAgICAgICBvbkVhY2hGZWF0dXJlOiAoZjogYW55LCBsOiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBwID0gZi5wcm9wZXJ0aWVzXG4gICAgICAgICAgbC5iaW5kUG9wdXAoYFxuICAgICAgICAgICAgPGI+8J+UpSBIb3RzcG90PC9iPjxici8+XG4gICAgICAgICAgICDguKfguLHguJnguJfguLXguYg6ICR7cC5EQVRFIHx8ICctJ308YnIvPlxuICAgICAgICAgICAg4LiI4Lix4LiH4Lir4Lin4Lix4LiUOiAke3AuUFJPVklOQ0UgfHwgJy0nfVxuICAgICAgICAgIGApXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmIChzaG93SG90c3BvdHMpIGhvdHNwb3RMYXllci5hZGRUbyhtYXApXG5cbiAgICAgIC8vIEhlYXRtYXBcbiAgICAgIGNvbnN0IHB0cyA9IGdlby5mZWF0dXJlcy5tYXAoKGY6IGFueSkgPT4gW1xuICAgICAgICBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLFxuICAgICAgICBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdXG4gICAgICBdKVxuXG4gICAgICBoZWF0TGF5ZXIgPSAoTCBhcyBhbnkpLmhlYXRMYXllcihwdHMsIHtcbiAgICAgICAgcmFkaXVzOiAyNSxcbiAgICAgICAgYmx1cjogMjAsXG4gICAgICAgIG1heFpvb206IDlcbiAgICAgIH0pXG5cbiAgICAgIGlmIChzaG93SG90c3BvdHMpIGhlYXRMYXllci5hZGRUbyhtYXApXG5cbiAgICAgIC8vIENvdW50IHBlciBwcm92aW5jZVxuICAgICAgY29uc3QgYm91bmRhcnkgPSBhd2FpdCBmZXRjaCgnL2dlby9wcm92aW5jZXMuZ2VvanNvbicpLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgIGNvbnN0IGNvdW50czogYW55ID0ge31cblxuICAgICAgZ2VvLmZlYXR1cmVzLmZvckVhY2goKHB0OiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgW2xvbiwgbGF0XSA9IHB0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzXG4gICAgICAgIGNvbnN0IHBvaW50ID0gdHVyZi5wb2ludChbbG9uLCBsYXRdKVxuXG4gICAgICAgIGJvdW5kYXJ5LmZlYXR1cmVzLmZvckVhY2goKGY6IGFueSkgPT4ge1xuICAgICAgICAgIGxldCBwb2x5XG4gICAgICAgICAgaWYgKGYuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKVxuICAgICAgICAgICAgcG9seSA9IHR1cmYucG9seWdvbihmLmdlb21ldHJ5LmNvb3JkaW5hdGVzKVxuICAgICAgICAgIGVsc2UgaWYgKGYuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpXG4gICAgICAgICAgICBwb2x5ID0gdHVyZi5tdWx0aVBvbHlnb24oZi5nZW9tZXRyeS5jb29yZGluYXRlcylcblxuICAgICAgICAgIGlmICh0dXJmLmJvb2xlYW5Qb2ludEluUG9seWdvbihwb2ludCwgcG9seSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3YgPSBmLnByb3BlcnRpZXMucHJvX3RoXG4gICAgICAgICAgICBjb3VudHNbcHJvdl0gPSAoY291bnRzW3Byb3ZdIHx8IDApICsgMVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHNvcnRlZCA9IE9iamVjdC5lbnRyaWVzKGNvdW50cykuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IGJbMV0gLSBhWzFdKVxuXG4gICAgICBsZXQgdG9wUHJvdmluY2UgPSBcIi1cIlxuXG4gICAgICBpZiAoc29ydGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdG9wUHJvdmluY2UgPSBgJHtzb3J0ZWRbMF1bMF19ICgke3NvcnRlZFswXVsxXX0g4LiI4Li44LiUKWBcblxuICAgICAgICBjb25zdCB0b3BGZWF0dXJlID0gYm91bmRhcnkuZmVhdHVyZXMuZmluZChcbiAgICAgICAgICAoZjogYW55KSA9PiBmLnByb3BlcnRpZXMucHJvX3RoID09PSBzb3J0ZWRbMF1bMF1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmICh0b3BGZWF0dXJlKSB7XG4gICAgICAgICAgdG9wUHJvdmluY2VMYXllciA9IEwuZ2VvSlNPTih0b3BGZWF0dXJlLCB7XG4gICAgICAgICAgICBzdHlsZTogeyBjb2xvcjogJ2JsYWNrJywgd2VpZ2h0OiAzLCBmaWxsT3BhY2l0eTogMC4yNSB9XG4gICAgICAgICAgfSkuYWRkVG8obWFwKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uU3RhdHNVcGRhdGUoe1xuICAgICAgICB0b3RhbEhvdHNwb3RzOiBnZW8uZmVhdHVyZXMubGVuZ3RoLFxuICAgICAgICB0b3BQcm92aW5jZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBsb2FkQm91bmRhcnkoKS50aGVuKCgpID0+IGxvYWRIb3RzcG90KHNlbGVjdGVkTW9udGgpKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChtYXApIG1hcC5yZW1vdmUoKVxuICAgIH1cblxuXG4gIH0sIFtzZWxlY3RlZE1vbnRoLCBzaG93SG90c3BvdHNdKVxuXG4gIHJldHVybiA8ZGl2IGlkPVwibWFwXCIgY2xhc3NOYW1lPVwiaC1bNzAwcHhdIHctZnVsbFwiPjwvZGl2PlxufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsIkwiLCJ0dXJmIiwiTWFwQ29tcG9uZW50Iiwic2VsZWN0ZWRNb250aCIsInNob3dIb3RzcG90cyIsIm9uU3RhdHNVcGRhdGUiLCJtYXBDb250YWluZXIiLCJEb21VdGlsIiwiZ2V0IiwiX2xlYWZsZXRfaWQiLCJtYXAiLCJjZW50ZXIiLCJ6b29tIiwidGlsZUxheWVyIiwiYXR0cmlidXRpb24iLCJhZGRUbyIsImhvdHNwb3RMYXllciIsImhlYXRMYXllciIsInRvcFByb3ZpbmNlTGF5ZXIiLCJib3VuZGFyeUxheWVyIiwibG9hZEJvdW5kYXJ5IiwiYm91bmRhcnkiLCJmZXRjaCIsInRoZW4iLCJyIiwianNvbiIsImdlb0pTT04iLCJzdHlsZSIsImNvbG9yIiwid2VpZ2h0IiwiZmlsbE9wYWNpdHkiLCJsb2FkSG90c3BvdCIsIm1vbnRoIiwiZmlsZSIsImdlbyIsInJlbW92ZUxheWVyIiwicG9pbnRUb0xheWVyIiwiXyIsImxhdGxuZyIsImNpcmNsZU1hcmtlciIsInJhZGl1cyIsImZpbGxDb2xvciIsIm9uRWFjaEZlYXR1cmUiLCJmIiwibCIsInAiLCJwcm9wZXJ0aWVzIiwiYmluZFBvcHVwIiwiREFURSIsIlBST1ZJTkNFIiwicHRzIiwiZmVhdHVyZXMiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwiYmx1ciIsIm1heFpvb20iLCJjb3VudHMiLCJmb3JFYWNoIiwicHQiLCJsb24iLCJsYXQiLCJwb2ludCIsInBvbHkiLCJ0eXBlIiwicG9seWdvbiIsIm11bHRpUG9seWdvbiIsImJvb2xlYW5Qb2ludEluUG9seWdvbiIsInByb3YiLCJwcm9fdGgiLCJzb3J0ZWQiLCJPYmplY3QiLCJlbnRyaWVzIiwic29ydCIsImEiLCJiIiwidG9wUHJvdmluY2UiLCJsZW5ndGgiLCJ0b3BGZWF0dXJlIiwiZmluZCIsInRvdGFsSG90c3BvdHMiLCJyZW1vdmUiLCJkaXYiLCJpZCIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/map-component.tsx\n"));

/***/ })

});